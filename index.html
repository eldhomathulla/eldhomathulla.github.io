<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Untitled Document</title>
<link href="css/bootstrap.css" rel="stylesheet" type="text/css">
<style type="text/css">
.photo {
	position: relative;
	height: 20%;
	width: 20%;
}
	
.subsection-header{
	border-bottom: thin solid;
	border-bottom-color: darkcyan;
	margin-bottom: 10px;
}
	
.diagram{
	width:100%;	
}
	
.sub-section{
		
}

.sub-2-section{
}
	
.each-section{
	border-bottom-style: solid;
	border-bottom-width: 10px;
	border-bottom-color: darkcyan;
	border-bottom-left-radius: 8px;
	border-bottom-right-radius: 8px;
	margin-bottom: 50px;
}
</style>
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>
<div class="container">
  
  <div class="row">
   <div class="col-xs-10"> <img src="https://jnfpdw.bn1304.livefilestore.com/y4mtlTz5_td7P4QYODKNDHJHY2FQ8TyClH_A7aW71i9KBSRywrnWPiogcGn15zl7xwRv2PJ6ZC-KmOU1HoSWpNjepsu5I_ccu8YHMA8M2U_HTdUD9Q6C6RqclInoyZ5MHFFhEU-6YXhnPt6m8k3-SzqB3R6rl7Zad8EdEfgc5MdwwS-eAlC27cwA_So5XBQDnjYm3xVMarYZd_V9uaJpDXo7w?width=495&height=660&cropmode=none" class="img-circle img-responsive photo" alt="Placeholder image"></div>
    <div class="col-xs-10"><h1>ELDHO MATHULLA</h1></div>    
  </div>
  <div class="row">
    	<section class="each-section">
    	<h2>Load Balancing and Service Discovery using Apache Curator</h2>
    	
    	<div class="sub-section">
    	<h3 class="subsection-header">Goal</h3>
    	<p>
    		The idea here is to see how it is possible to use the Apache Curator a high-level API for zookeeper for Service Discovery and Load Balancing, and should Service Discovery and what are the benefits and pitfalls of such an approach.
    	</p>	
    	</div>

    	<div class="sub-section">
    	<h3 class="subsection-header">Architecture</h3>
    	<p>
    		Apache Curator is primarily a high-level Zookeeper API for Java. In order to provide the functionalities provided by Curator for other languages than Java, it provides 2 different options: Service Discovery Server and Curator RPC. In this implementation, I am using the Curator RPC. Curator RPC is a small curator client built using java which exposes all the curator APIs through Apache Thrift Interface.  Using this, all the languages supported by Apache Thrift can use the Curator Functionality.
    	</p>
		<img src="https://image.ibb.co/jyBPMF/Service_discovery_Load_Balancing.png" class="diagram">
  		</div>
   		<div class="sub-section">
   		<h3 class="subsection-header">Service Discovery</h3>
   		<p>
   			Service Discovery part of the curator is straight forward, as it provides direct APIs for doing so. The service has to register with the zookeeper using the curator API along with URL to access it, nad the name of the service. And the service has to keep one polling the Curator RPC in the required interval to make sure that the service remains available, otherwise, the Curator RPC deletes the service entry from the zookeeper.
   		</p>
   		<p>
   			For discovering the APIs, the client which wants to avail the server can use the Curator RPC thrift API to get the list of available service under a given service name.
   		</p>
   		</div>
   		<div class="sub-section">
   		<h3 class="subsection-header">Load Balancing</h3>
   		<p>
   			Apache Curator doesn't support the load balancing part out of the box. Therefore, we need to use the features provided in the service discovery API of Apache Curator to implement the load balancing part.
   		</p>
   		<p>
   			This is where the advantage and pitfalls of using Apache curator for load balancing come into play. The way in which it is implemented is that Along with the registration of service in the zookeeper, Curator allows you to store an additional field which can be used for any purpose. Using this field, each time lets say we can update the Processor Usage for the instance in which the service is running. The client which needs to access the service can then use the service with least processor usage during the service discovery part.
   		</p>
   		<p>
   			Instead of Processor usage, technically any metric of out choice can be used for load balancing. This gives enormous flexibility over the metric that can be used for load balancing, i.e. different service can use different metrics for different service types.
   		</p>
   		<p>
   			The disadvantage of this approach is that it is up to the service to fetch and update this information in the zookeeper. This means that a portion of the load balancing rests on the shoulder of the services which is not an ideal solution. This can alleviate by building some common metric fetching part to the curator RPC. Unfortunately, due to the time constraint, this part won't be implemented in this implementation.
   		</p>
   		</div>
   		<div class="sub-section">
   		<h3 class="subsection-header">Advantages of using this approach</h3>
   			<p>
   				The primary advantage of this approach is the flexibility, .i.e it allows to load balance based on whatever parameters. This approach will give you flexibility to load balance using different approached for different service types. 
   			</p>
   		</div>
   		<div class="sub-section">
   			<h3 class="subsection-header">Final Note</h3>
   			<p>Even though load balancing using Apache curator leveraging Apache Curarator givey you immense flexibility, it also has sever disadvantages. The first on is that the approach I have used will require atleast 2 request for acces a microservices. This can be removed by routing the requests directly through the load balancer. </p>
   			<p>
   				The biggest problem is that it requires code changes to the microservices to fetch the metric used for load balancing of desired choice, and service registration. Even this problem can be alleviated by building an agent which will do all those things which will run separately where the service resides. This will again create an overhead of executing the agent itself.
   			</p>
   			<p> 
   			Everything considered, it is not best approach for both load balancing and services discovery to use Zookper using Apache Curator
   			</p>
   		</div>
    	</section>
    	<section class="each-section">
    		<h2>Django Portal User Interface</h2>
    		<div class="sub-section">
    			<h3 class="subsection-header">Goal</h3>
    			<p>
    				The main goal of this is to come up with possible technologies and high level approach for the user interface structure and underlying portal backend, for the django portal. Following where the key things to be considered for such a structure:
    				<ul>
    					<li>Should be able to integrate different sections within the portal seamlesly</li>
    					<li>Should be flexible in allowing use of approach and technolgies in development of the UI</li>
    					<li>Each Section should be contained within itself and should not intefer with other sections of the portal</li>
    				</ul>
    			</p>
    		</div>
    		<div class="sub-section">
    			<h3 class="subsection-header">Approaches</h3>
    			<p>
    				There are 2 different approaches that have been considered.
    			</p>
    			<p>
    				The first one is using a javascript heavy frontend, i.e. all UI processing will be done on the client side using javascript. In this approach, the Django portal backend will simply act as a conduit for fetching the data required for the user interface. This means that the user interface itself will be highly decoupled from the middleware. 
    			</p>
    			<p>
    				The advantage of such an approach is that, since UI is not tightly coupled with the middleware, these 2 can be more independently developed as well as integrating both will be easier. Also, more structured UI component can be developed and helps to boost the reusability id UI components.
    			</p>
    			<p>
    				The major problem with the client side heavy UI processing is that the code base of the user interface become very complicated and will require the use of MVC like frameworks like Angularjs and Ember. This means that only people who have advanced skills in JavaScript, can be involved in developing the user interface. This also means that flexibility in using the frontend technologies also get greatly reduced
    			</p>
   			  <p>
    				The second approach is to isolate the User interface of the different section from that of the main section. The best way to do so was through the use of iframes. This allows to provide the necessary flexibility as a  part of the portal can be developed independently in any manner without interfering with other section and allows to use either client heavy user interface processing or a mix of client heavy user interface processing as well as backend user interface processing or exclusively using backend user interface processing if required. This approach will allow people with just basic skills in front-end development to create user interfaces as well.
   			  </p>
    		</div>
   		  <div class="sub-section">
   			<h3 class="subsection-header">Conclusion</h3>
   			Inorder to provide flexibility in where the UI processing is done, the seccond approach will be the better fit, as it can be used in such a way that a seamless Single Page Applications may be create if wanted, or an application where most of the UI processing is done in the django itself. In this approch all the navigation related stuff will be common for all the applications as it will be defined outside the in iframe itself.
		</div>
    	</section>
    	<section class="each-section">
    		<h2>Caching on Django Portal</h2>
    		<div class="sub-section">
    			<h3 class="subsection-header">Goal</h3>
    			<p>Main goal of this is to decide what level of caching should be used.</p>
    		</div>
    		<div class="sub-section">
    			<h3 class="subsection-header">What level of caching should be used?</h3>
    			<p>In Django, there are multiple places where the caching can be implemented. These are as follows:</p>
    			<ol>
    				<li>Views</li>
    				<li>Request response</li>
    				<li>Model Objects</li>
    				<li>Database query results</li>
    				<li>Thrift calls</li>
    			</ol>
    			<div class="sub-2-section">
    				<h4>Views</h4>
    				<p>
    					In caching of views whatâ€™s done is that the result a call to a view will be cached. The advantage of this approach is that since the views encompass all the things that can be cached, caching the view itself will cache everything relative to the corresponding view. It might possibly eliminate a need for caching in other areas, depending on the use case.
    				</p>
    				<p>
    					Django's default caching mechanism provides caching for dynamic pages which may be created from data obtained from multiple sources. Django by default provides multiple sources as a data store for caching, such as external files, Memcache, database and local memory caching. Apart from the default caching available in Django, a Redis based cache for the same has been implemented, so as to provide an alternative to Memcache for Distributed Caching.
    				</p>
    				<p>
    					The main problem with this level of caching is that since the pages are cached, there is very little granularity of the things cached. I.e. all the shared data used between different pages will be essentially be cached multiple times, which make it redundant. Also, this level of caching will be irrelevant when most of the UI processing is done on the client side and not Django backend.
    				</p>
    			</div>
    			<div class="sub-2-section">
    				<h4>Request reponse</h4>
    				<p>
    					Within the Django caching framework, it allows for caching of the response to the corresponding request.This means that everything including the views will be cached without any distinction.This has a clear advantage over the caching of the views where any the caching can be applied effectively to cases where most of the UI processing is done on the client side, which in most cases means that Django provides APIs for fetching data required by the UI, which can be cached using this level of caching. This level of caching shares the same Django caching framework.
    				</p>
    			</div>
    		</div>
    	</section>
    	<section class="each-section">
    		<h2>Distributed Session Management in Django</h2>
    		<div class="sub-section">
    			<h3 class="subsection-header">Goal</h3>
    			<p>The main goal here is to find an approach in Django which provides an optimal solution for managing distributed session mangement.</p>
    		</div>
    	</section>
</div>
</div>
</body>
</html>
